/*!
 * @zevanoo/baileys-ez v1.0.0
 * Copyright (c) 2025 Zevano
 * Licensed under MIT
 */

import{SessionManager as a}from"../client/session.js";const o=["connection","error","chat","chat.add","chat.update","chat.remove","chat.phone-share","history.set","contact","contact.add","contact.update","group","group.add","group.update","group.member.add","group.member.remove","group.member.promote","group.member.demote","group.request.join","message","message.new","message.update","message.remove","message.receipt","message.react","message.media.update","call","presence.update","blocklist","blocklist.set","blocklist.add","blocklist.remove","label","label.edit","label.association.add","label.association.remove","newsletter","newsletter.view","newsletter.react","newsletter-participants.update","newsletter-settings.update","session.removed"];class r extends a{constructor({folderName:e="sessions",pairingCode:s,serializer:t,baileysConfig:i={}}){super(e),this.serializer=t,this.baileysConfig=i,this.clients=new Map,this.pairingCode=s}addClient(e){this.clients.set(e.id,e);for(const s of o)e.on(s,t=>{this.emit(s,{data:t,clientId:e.id})})}async removeClient(e){const s=this.getClient(e);await(s==null?void 0:s.disconnect()),this.clients.delete(e)}getClient(e){return this.clients.get(e)}getAllClients(){return Array.from(this.clients.values())}async connectAll(){const s=Array.from(this.clients.keys()).map(t=>this.clients.get(t).connect());await Promise.all(s)}async disconnectAll(){const e=Array.from(this.clients.values()).map(s=>s.disconnect());await Promise.all(e)}getClientSessionPaths(){const e=[];for(const s of this.clients.values())s.sessionPath&&e.push(s.sessionPath);return e}async checkAllClientSessions(){const e=[];for(const s of this.clients.values())if(s.sessionPath){const t=await this.checkIndividualSessionStatus(s.sessionPath);e.push({id:s.id,path:s.sessionPath,valid:t.valid,reason:t.reason})}return e}async cleanClientSessions(){let e=0;for(const s of this.clients.values())if(s.sessionPath){const t=await this.checkIndividualSessionStatus(s.sessionPath);t.valid||(console.log(`Cleaning invalid client session (${t.reason}): ${s.sessionPath}`),await this.validateAndCleanIndividualSession(s.sessionPath),e++)}return e}async listAllSessionsWithClients(){const s=(await this.listAllSessions()).map(t=>({...t,source:"base"}));for(const t of this.clients.values())if(t.sessionPath){const i=s.findIndex(n=>n.path===t.sessionPath);if(i===-1){const n=await this.checkIndividualSessionStatus(t.sessionPath);s.push({id:t.id,path:t.sessionPath,valid:n.valid,reason:n.reason,source:"client"})}else s[i].source="client"}return s}async cleanAllSessionsWithClients(){const e=this.getClientSessionPaths();return await this.cleanAllSessions(e)}}export{r as Wrapper};
