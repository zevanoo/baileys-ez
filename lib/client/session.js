/*!
 * @zevanoo/baileys-ez v1.0.0
 * Copyright (c) 2025 Zevano
 * Licensed under MIT
 */

import{EventEmitter as g}from"events";import o from"fs/promises";import r from"path";import{glob as f}from"glob";class y extends g{constructor(s="sessions"){super(),this.baseSessionPath=r.join(process.cwd(),s)}_getErrorMessage(s){return s instanceof Error?s.message:String(s)}async _pathExists(s){try{return await o.access(s),!0}catch{return!1}}async checkIndividualSessionStatus(s){try{const e=r.join(s,"creds.json");await o.access(e);const i=await o.readFile(e,"utf8"),t=JSON.parse(i),n=(t==null?void 0:t.registered)===!0,a=["noiseKey","pairingEphemeralKeyPair","signedIdentityKey","signedPreKey"].every(l=>t==null?void 0:t[l]);return{exists:!0,registered:n,valid:n&&a,reason:a?void 0:"Missing required authentication fields"}}catch(e){const i=this._getErrorMessage(e);return i.includes("ENOENT")?{exists:!1,registered:!1,valid:!1,reason:"File or directory not found"}:{exists:!0,registered:!1,valid:!1,reason:i}}}async validateAndCleanIndividualSession(s){try{const e=await this.checkIndividualSessionStatus(s);!e.valid&&e.exists&&(console.log(`Cleaning invalid session (${e.reason}): ${s}`),await o.rm(s,{recursive:!0,force:!0}))}catch(e){console.error(`Error in validateAndCleanIndividualSession for ${s}:`,this._getErrorMessage(e))}}async cleanupCorruptSessions(){try{const s=await f(`${this.baseSessionPath}/*/`);for(const e of s)await this.validateAndCleanIndividualSession(e)}catch(s){console.error("Error during session cleanup:",this._getErrorMessage(s))}}async listValidSessions(){const s=[];try{const e=await f(`${this.baseSessionPath}/*/`);for(const i of e)(await this.checkIndividualSessionStatus(i)).valid&&s.push(r.basename(i))}catch(e){console.error("Error connecting all sessions:",this._getErrorMessage(e))}return console.log(`Found ${s.length} valid sessions:`,s),s}async removeSession(s){const e=r.join(this.baseSessionPath,s);try{return await o.access(e),await o.rm(e,{recursive:!0,force:!0}),console.log(`Removed session folder: ${e}`),this.emit("session.removed",{sessionId:s}),!0}catch(i){const t=this._getErrorMessage(i);return t.includes("ENOENT")?console.log(`Session folder does not exist, cannot remove: ${e}`):console.error(`Failed to remove session folder ${e}:`,t),!1}}async getSessionInfo(s){const e=r.join(this.baseSessionPath,s);return await this.checkIndividualSessionStatus(e)}async listAllSessions(s=[]){const e=[this.baseSessionPath,...s],i=[];for(const t of e)if(await this._pathExists(t)){const n=await o.readdir(t);for(const c of n){const a=r.join(t,c);if((await o.stat(a)).isDirectory()){const d=r.join(a,"creds.json"),h=await this._pathExists(d)?await this.checkIndividualSessionStatus(a):{exists:!0,registered:!1,valid:!1,reason:"No creds.json"};i.push({id:c,path:a,valid:h.valid,reason:h.reason})}}}return i}async cleanAllSessions(s=[]){const e=[this.baseSessionPath,...s];let i=0;for(const t of e)if(await this._pathExists(t)){const n=await o.readdir(t);for(const c of n){const a=r.join(t,c);if((await o.stat(a)).isDirectory()){const d=r.join(a,"creds.json");if(await this._pathExists(d)){const u=await this.checkIndividualSessionStatus(a);u.valid||(console.log(`Cleaning invalid session (${u.reason}): ${a}`),await o.rm(a,{recursive:!0,force:!0}),i++)}else console.log(`Removing non-essential session folder (no creds.json): ${a}`),await o.rm(a,{recursive:!0,force:!0}),i++}}}return i}}export{y as SessionManager};
